# Bash auto-completion file for binwalk

_binwalk()
{
	local cur prev opts long_opts short_opts file_opts

	COMPREPLY=()
	cur="${COMP_WORDS[COMP_CWORD]}"
	prev="${COMP_WORDS[COMP_CWORD-1]}"

	# Long and short options are dynamically generated by setup.py
	long_opts="%%LONG_OPTS%%"
	short_opts="%%SHORT_OPTS%%"
	file_opts="--file --extract --magic"
	opts="${long_opts} ${short_opts}"

	# If this is a long option, then tab complete a list of matching long options
	if [[ ${cur} == --* ]]
	then
		COMPREPLY=( $(compgen -W "${long_opts}" -- ${cur}) )
	# Else, if this is any other option, tab complete it from then entire list of valid options
	elif [[ ${cur} == -* ]]
	then
		COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
	# Finally, if this is not an option at all, tab complete a list of files
	else
		COMPREPLY=( $(compgen -f ${cur}) )
	fi

	# If there is only one matching option, and if it is a long option, then don't put a space after the equals sign.
	if [ "$(echo "$COMPREPLY" | wc -w)" == "1" ] && [ "$(echo "$COMPREPLY" | grep -e '=$')" != "" ]
	then
		compopt -o nospace;
	# Else, if there are no matching options, check to see if the previous option is a long option that takes a file path argument
	elif [ "$COMPREPLY" == "" ]
	then
		for file_opt in ${file_opts}
		do
			if [ "${prev}" == "${file_opt}" ]
			then
				# If the previous option does take a file path argument, tab complete a list of files
				COMPREPLY=( $(compgen -f "") )
				break
			fi
		done
	fi

	return 0
}

complete -F _binwalk binwalk

